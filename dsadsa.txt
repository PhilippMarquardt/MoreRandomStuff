import polars as pl

POS_W = ["initial_weight", "resulting_weight", "initial_exposure_weight", "resulting_exposure_weight"]
REF_W = "weight"   # selected/contractual use "weight"
LT_W  = "weight"   # lookthrough child weight (joined as weight_right)

def _suffix_from_factor_col(fcol: str) -> str:
    # f_{config}_{pid} -> {config}_{pid}
    return fcol[2:]

def build_initial_metrics_all_levels(
    positions_lf: pl.LazyFrame,
    lookthroughs_lf: pl.LazyFrame | None,
    metadata_map: dict,   # {config_name: {pid: "f_{config}_{pid}"}}
) -> dict[str, pl.LazyFrame]:
    """
    Returns: {"no": lf, "essential": lf, "complete": lf}
    Each lf contains PI, PR, BS, BC computed per (config_name, perspective_id, instrument_id, parent_instrument_id, sub_portfolio_id, container).
    """

    out = {"no": [], "essential": [], "complete": []}

    for config_name, pmap in metadata_map.items():
        for pid, fcol in pmap.items():
            suffix = _suffix_from_factor_col(fcol)

            # PSP-produced per-perspective weight columns
            iw  = f"initial_weight_{suffix}"
            rw  = f"resulting_weight_{suffix}"
            iew = f"initial_exposure_weight_{suffix}"
            rew = f"resulting_exposure_weight_{suffix}"
            wref = f"{REF_W}_{suffix}"     # references
            wlt  = f"{LT_W}_{suffix}"      # lookthroughs

            # kept positions for this perspective
            pos = (
                positions_lf
                .filter(pl.col(fcol).is_not_null())
                .with_columns([
                    pl.lit(config_name).alias("config_name"),
                    pl.lit(int(pid)).alias("perspective_id"),
                ])
            )

            IS_HOLDING     = pl.col("container") == "holding"
            IS_SELECTED    = pl.col("container") == "selected_reference"
            IS_CONTRACTUAL = pl.col("container") == "contractual_reference"

            # -------------------------
            # Level = "no"  (no join)
            # -------------------------
            no_lf = (
                pos.with_columns([
                    # holdings use initial_weight / resulting_weight at level "no"
                    pl.when(IS_HOLDING).then(pl.col(iw)).otherwise(pl.lit(None)).alias("PI"),
                    pl.when(IS_HOLDING).then(pl.col(rw)).otherwise(pl.lit(None)).alias("PR"),

                    # references always come from "weight"
                    pl.when(IS_SELECTED).then(pl.col(wref)).otherwise(pl.lit(None)).alias("BS"),
                    pl.when(IS_CONTRACTUAL).then(pl.col(wref)).otherwise(pl.lit(None)).alias("BC"),

                    # no underlying => parent == instrument
                    pl.col("instrument_id").alias("parent_instrument_id"),
                ])
                .select([
                    "config_name", "perspective_id",
                    "sub_portfolio_id",
                    "container",
                    "instrument_id", "parent_instrument_id",
                    "PI", "PR", "BS", "BC",
                ])
            )
            out["no"].append(no_lf)

            # If we have no lookthroughs, skip essential/complete
            if lookthroughs_lf is None:
                continue

            # Build common LT frame for this perspective (kept children)
            # IMPORTANT: rename child cols so we don't rely on Polars "_right" suffixing.
            def lt_for(record_type_value: str) -> pl.LazyFrame:
                return (
                    lookthroughs_lf
                    .filter(
                        pl.col(fcol).is_not_null()
                        & (pl.col("record_type") == record_type_value)
                    )
                    .select([
                        "parent_instrument_id",
                        "sub_portfolio_id",
                        pl.col("instrument_id").alias("instrument_id_right"),
                        pl.col(wlt).alias("weight_right"),
                    ])
                )

            # -------------------------
            # Level = "essential" / "complete"
            # holdings: if underlying exists => exposure_weight * weight_right
            # holdings: if no underlying     => exposure_weight
            # references: same as always
            # -------------------------
            for level, rt in [("essential", "essential_lookthroughs"), ("complete", "complete_lookthroughs")]:
                lt = lt_for(rt)

                joined = (
                    pos.join(
                        lt,
                        how="left",
                        left_on=["instrument_id", "sub_portfolio_id"],
                        right_on=["parent_instrument_id", "sub_portfolio_id"],
                        coalesce=False,
                    )
                )

                child_present = pl.col("instrument_id_right").is_not_null()

                level_lf = (
                    joined.with_columns([
                        # parent_instrument_id logic: if child exists, parent = original instrument_id; else parent=instrument_id
                        pl.col("instrument_id").alias("parent_instrument_id"),

                        # instrument_id becomes child when child exists
                        pl.when(child_present)
                          .then(pl.col("instrument_id_right"))
                          .otherwise(pl.col("instrument_id"))
                          .alias("instrument_id"),

                        # holdings PI/PR logic at LT levels uses exposure weights
                        pl.when(IS_HOLDING & child_present)
                          .then(pl.col(iew) * pl.col("weight_right"))
                          .when(IS_HOLDING & ~child_present)
                          .then(pl.col(iew))
                          .otherwise(pl.lit(None))
                          .alias("PI"),

                        pl.when(IS_HOLDING & child_present)
                          .then(pl.col(rew) * pl.col("weight_right"))
                          .when(IS_HOLDING & ~child_present)
                          .then(pl.col(rew))
                          .otherwise(pl.lit(None))
                          .alias("PR"),

                        # references unchanged
                        pl.when(IS_SELECTED).then(pl.col(wref)).otherwise(pl.lit(None)).alias("BS"),
                        pl.when(IS_CONTRACTUAL).then(pl.col(wref)).otherwise(pl.lit(None)).alias("BC"),
                    ])
                    .select([
                        "config_name", "perspective_id",
                        "sub_portfolio_id",
                        "container",
                        "instrument_id", "parent_instrument_id",
                        "PI", "PR", "BS", "BC",
                    ])
                )

                out[level].append(level_lf)

    # concat per level
    return {
        lvl: (pl.concat(frames, how="vertical_relaxed") if frames else pl.LazyFrame())
        for lvl, frames in out.items()
    }



  Location: _df_to_dict() method, lines 644-645

  # Lines 644-645 currently:
  if 'result' in result_output_df.columns.tolist():
       result_output_df = result_output_df[result_output_df['result'] == True]

  To add zero-weight filtering after line 645:
  # Add: Filter positions where all weights are 0
  result_output_df = result_output_df[
      ~result_output_df[weight_labels].eq(0).all(axis=1)
  ]
