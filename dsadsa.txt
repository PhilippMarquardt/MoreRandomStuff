0) Input columns / Begriffe

container âˆˆ {holding, selected_reference, contractual_reference}
position_type âˆˆ {holding, reference} (used by apply_to)
record_type âˆˆ {position, essential_lookthroughs, complete_lookthroughs} (only on lookthrough DF)
weight label = numeric column, e.g. market_value_weight, tna_weight, â€¦

Base IDs:

positions: identifier, instrument_id, sub_portfolio_id, container, position_type, weightsâ€¦

lookthroughs: identifier, parent_instrument_id, sub_portfolio_id, container, position_type, record_type, weightsâ€¦

1) Build factor columns per (config, pid)

For each configuration config and perspective id pid create:

Column name

factor column: f_{config}_{pid}

Semantics

f_{config}_{pid} = NULL â†’ row is removed for that perspective

f_{config}_{pid} = s > 0 â†’ row is kept, and s is the base scaling factor (from scaling rules)

Keep predicate (minimal, high-level)

Define:

PreKeep(pid) = AND over preprocessing modifiers: â€œdo not match preproc criteriaâ€ (per modifier; combined with AND)

RuleKeep(pid) = boolean chaining of non-scaling perspective rules (respecting rule-to-next-rule and/or)

PostAdjust(pid) = apply postprocessing â€œsaviorâ€ modifiers by OR/AND into the running rule result (again chained inside rule result)

Then:

Keep: K(pid) = PreKeep(pid) âˆ§ RuleKeep_after_post(pid)

And:

Base scaling: S(pid) = âˆ(scale_factor_r) over scaling rules that match (starts at 1.0, multiplied by each scaling ruleâ€™s factor)

Finally the factor column is:

f_{config}_{pid} = S(pid) if K(pid) else NULL

So: keep first, then scaling rules provide the value written into the factor column.

1.1) Lookthrough synchronization (parent â†’ child)

After computing factor columns on both frames, lookthroughs are synchronized:

For each factor column f = f_{config}_{pid}:

group parents by (instrument_id, sub_portfolio_id)

if ANY parent has f = NULL â‡’ child factor becomes NULL

else child keeps its factor

Effect: if a parent position is removed for a perspective, all its lookthrough children disappear for that perspective.

2) Optional rescaling (normalization to 100%)

Rescaling is enabled per perspective via modifiers:

positions: scale_holdings_to_100_percent

lookthroughs: scale_lookthroughs_to_100_percent

Rescaling does not overwrite f_{config}_{pid}.
It creates an additional struct column per factor:

Column name

rescale factor struct: f_{config}_{pid}_factors

Meaning

f_{config}_{pid}_factors is a struct with one field per weight label w:

field name: w

value: the effective factor to use for weight w

2.1) Positions rescaling (per container, not per sub_portfolio)

For each rescaled perspective factor f and each weight label w:

Denominator per container

ğ·
ğ‘
,
ğ‘“
,
ğ‘¤
=
âˆ‘
ğ‘–
âˆˆ
ğ‘
ğ‘œ
ğ‘ 
(
ğ‘
)
ğ‘¤
ğ‘–
â‹…
ğ‘“
ğ‘–
â€…â€Š
+
â€…â€Š
âˆ‘
ğ‘—
âˆˆ
ğ¸
ğ¿
ğ‘‡
(
ğ‘
)
ğ‘¤
ğ‘—
â‹…
ğ‘“
ğ‘—
D
c,f,w
	â€‹

=
iâˆˆpos(c)
âˆ‘
	â€‹

w
i
	â€‹

â‹…f
i
	â€‹

+
jâˆˆELT(c)
âˆ‘
	â€‹

w
j
	â€‹

â‹…f
j
	â€‹


(ELT = lookthrough rows with record_type = essential_lookthroughs, only if that weight exists on lookthroughs)

Stored factor field per row

ğ‘“
ğ‘
ğ‘
ğ‘¡
ğ‘œ
ğ‘Ÿ
ğ‘ 
ğ‘–
[
ğ‘¤
]
=
{
ğ‘“
ğ‘–
ğ·
ğ‘
,
ğ‘“
,
ğ‘¤
	
if 
ğ‘“
ğ‘–
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿
âˆ§
ğ·
ğ‘
,
ğ‘“
,
ğ‘¤
â‰ 
0


ğ‘“
ğ‘–
	
otherwise
factors
i
	â€‹

[w]={
D
c,f,w
	â€‹

f
i
	â€‹

	â€‹

f
i
	â€‹

	â€‹

if f
i
	â€‹

î€ 
=NULLâˆ§D
c,f,w
	â€‹

î€ 
=0
otherwise
	â€‹


This is stored as:

f_factors = struct({ w1: factors[w1], w2: factors[w2], ... })

2.2) Lookthrough rescaling (per parent group)

Groups:

(container, parent_instrument_id, record_type, sub_portfolio_id)

For each rescaled factor f and weight w:

ğ·
ğ‘”
,
ğ‘“
,
ğ‘¤
=
âˆ‘
ğ‘—
âˆˆ
ğ‘”
ğ‘¤
ğ‘—
â‹…
ğ‘“
ğ‘—
(only rows with 
ğ‘“
ğ‘—
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿
 and parent-match flag true)
D
g,f,w
	â€‹

=
jâˆˆg
âˆ‘
	â€‹

w
j
	â€‹

â‹…f
j
	â€‹

(only rows with f
j
	â€‹

î€ 
=NULL and parent-match flag true)

Per row:

ğ‘“
ğ‘
ğ‘
ğ‘¡
ğ‘œ
ğ‘Ÿ
ğ‘ 
ğ‘—
[
ğ‘¤
]
=
{
ğ‘“
ğ‘—
ğ·
ğ‘”
,
ğ‘“
,
ğ‘¤
	
if 
ğ‘“
ğ‘—
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿
âˆ§
ğ·
ğ‘”
,
ğ‘“
,
ğ‘¤
â‰ 
0


ğ‘“
ğ‘—
	
otherwise
factors
j
	â€‹

[w]={
D
g,f,w
	â€‹

f
j
	â€‹

	â€‹

f
j
	â€‹

	â€‹

if f
j
	â€‹

î€ 
=NULLâˆ§D
g,f,w
	â€‹

î€ 
=0
otherwise
	â€‹


Stored in f_{config}_{pid}_factors the same way.

3) Final output weight columns (materialized in processor)

For each perspective factor column f = f_{config}_{pid}, each weight label w:

Column name

final weight output: {w}_{config}_{pid}

Value

If rescaling struct exists:

ğ‘¤
ğ‘
ğ‘œ
ğ‘›
ğ‘“
ğ‘–
ğ‘”
,
ğ‘
ğ‘–
ğ‘‘
=
{
ğ‘¤
â‹…
ğ‘“
_
ğ‘“
ğ‘
ğ‘
ğ‘¡
ğ‘œ
ğ‘Ÿ
ğ‘ 
[
ğ‘¤
]
	
if 
ğ‘“
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿


ğ‘
ğ‘ˆ
ğ¿
ğ¿
	
if 
ğ‘“
=
ğ‘
ğ‘ˆ
ğ¿
ğ¿
w
config,pid
	â€‹

={
wâ‹…f_factors[w]
NULL
	â€‹

if f
î€ 
=NULL
if f=NULL
	â€‹


If no rescaling struct:

ğ‘¤
ğ‘
ğ‘œ
ğ‘›
ğ‘“
ğ‘–
ğ‘”
,
ğ‘
ğ‘–
ğ‘‘
=
{
ğ‘¤
â‹…
ğ‘“
	
if 
ğ‘“
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿


ğ‘
ğ‘ˆ
ğ¿
ğ¿
	
if 
ğ‘“
=
ğ‘
ğ‘ˆ
ğ¿
ğ¿
w
config,pid
	â€‹

={
wâ‹…f
NULL
	â€‹

if f
î€ 
=NULL
if f=NULL
	â€‹


So OutputFormatter only selects {w}_{config}_{pid} and renames back to w for the JSON.

4) Scale factors dict (kept fraction per container/perspective/weight)

Output location:

results[config][pid][container]["scale_factors"][w]

Definitions for each container c, perspective factor f, weight w:

Total universe mass (raw weights, includes essential LT where present):

ğ‘‡
ğ‘
,
ğ‘¤
=
âˆ‘
ğ‘–
âˆˆ
ğ‘
ğ‘œ
ğ‘ 
(
ğ‘
)
ğ‘¤
ğ‘–
â€…â€Š
+
â€…â€Š
âˆ‘
ğ‘—
âˆˆ
ğ¸
ğ¿
ğ‘‡
(
ğ‘
)
ğ‘¤
ğ‘—
T
c,w
	â€‹

=
iâˆˆpos(c)
âˆ‘
	â€‹

w
i
	â€‹

+
jâˆˆELT(c)
âˆ‘
	â€‹

w
j
	â€‹


If scale_holdings_to_100_percent is OFF for that perspective:

scale_factors[w] = 1.0

If scale_holdings_to_100_percent is ON:
Kept mass uses â€œeconomic massâ€ = w * f (consistent with how rescaling denom was defined):

ğ¾
ğ‘
,
ğ‘“
,
ğ‘¤
=
âˆ‘
ğ‘–
âˆˆ
ğ‘
ğ‘œ
ğ‘ 
(
ğ‘
)
,
ğ‘“
ğ‘–
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿
ğ‘¤
ğ‘–
â‹…
ğ‘“
ğ‘–
â€…â€Š
+
â€…â€Š
âˆ‘
ğ‘—
âˆˆ
ğ¸
ğ¿
ğ‘‡
(
ğ‘
)
,
ğ‘“
ğ‘—
â‰ 
ğ‘
ğ‘ˆ
ğ¿
ğ¿
ğ‘¤
ğ‘—
â‹…
ğ‘“
ğ‘—
K
c,f,w
	â€‹

=
iâˆˆpos(c),f
i
	â€‹

î€ 
=NULL
âˆ‘
	â€‹

w
i
	â€‹

â‹…f
i
	â€‹

+
jâˆˆELT(c),f
j
	â€‹

î€ 
=NULL
âˆ‘
	â€‹

w
j
	â€‹

â‹…f
j
	â€‹


Then:

ğ‘†
ğ¹
ğ‘
,
ğ‘“
,
ğ‘¤
=
{
ğ¾
ğ‘
,
ğ‘“
,
ğ‘¤
ğ‘‡
ğ‘
,
ğ‘¤
	
if 
ğ‘‡
ğ‘
,
ğ‘¤
â‰ 
0


(omit)
	
if 
ğ‘‡
ğ‘
,
ğ‘¤
=
0
SF
c,f,w
	â€‹

={
T
c,w
	â€‹

K
c,f,w
	â€‹

	â€‹

(omit)
	â€‹

if T
c,w
	â€‹

î€ 
=0
if T
c,w
	â€‹

=0
	â€‹


Intent downstream:

notional attribution often uses something like TNA * output_weight * SF to reconstruct correct â€œkeptâ€ economic size.